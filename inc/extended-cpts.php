<?php
/*
Plugin Name:  Extended CPTs
Description:  Extended custom post types.
Version:      2.2.3
Author:       John Blackbourn
Author URI:   http://johnblackbourn.com
License:      GPL v2 or later

Copyright Â© 2012 John Blackbourn

Extended CPTs provides extended functionality to custom post types in WordPress, allowing you to quickly build custom post types without having to write the same code again and again.

= Improved defaults =

 * Public post type with admin UI enabled
 * Intelligent values for labels and post updated messages
 * Hierarchical with page capability type
 * Drop with_front from rewrite rules
 * Support post thumbnails
 * Optimal admin menu placement

= Extended features =

 * Ridiculously easy custom admin columns:
   - Add columns for post meta, taxonomy terms, post fields, featured image, Posts 2 Posts connections, and callback functions
   - Add columns depending on user capabilities
   - Out of the box sorting by post meta, taxonomy terms, and post fields
   - Specify a default sort column and sort order
 * Custom admin screen filters for post meta and taxonomy terms
 * Easily override any query variables such as posts_per_page, orderby, order and nopaging
 * Add post type archives to the nav menu screen
 * Add CPTs to the site's main feed
 * Add CPTs to the 'Right Now' section on the dashboard
 * Easily set the 'Enter title here' text
 * Easily set the 'Featured Image' title

= @TODO =

 * Checkbox type for meta_exists thingy
 * Allow checkbox, radio and text input admin screen filters
 * Allow overriding of post updated messages via the $args parameter

= License =

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

*/


/**
 * Wrapper function for instantiating a new ExtendedCPT object. This is the only function you need.
 * See the ExtendedCPT class constructor for parameters.
 */
function register_extended_post_type( $post_type, $args = array(), $plural = null, $slug = null, $singular = null ) {
	return new ExtendedCPT( $post_type, $args, $plural, $slug, $singular );
}

class ExtendedCPT {

	/**
	 * Default arguments for custom post types.
	 * Many of these are different from those found in WordPress' register_post_type() function.
	 *
	 * @var array
	 */
	protected $defaults = array(
		'public'               => true,
		'publicly_queryable'   => true,
		'exclude_from_search'  => false,
		'show_ui'              => true,
		'show_in_menu'         => true,
		'menu_position'        => 6,
		'menu_icon'            => null,
		'capability_type'      => 'page',
		'hierarchical'         => true,
		'supports'             => array( 'title', 'editor', 'thumbnail' ),
		'has_archive'          => true,
		'query_var'            => true,
		'can_export'           => true,
		'show_in_nav_menus'    => true,
		'archive_in_nav_menus' => true,  # Custom arg
		'quick_edit'           => true,  # Custom arg
		'right_now'            => null,  # Custom arg
		'show_in_feed'         => false, # Custom arg
		'archive'              => null,  # Custom arg
		'cols'                 => null,  # Custom arg
		'filters'              => null,  # Custom arg
		'enter_title_here'     => null,  # Custom arg
		'featured_image'       => null,  # Custom arg
	);

	/**
	 * Some other member variables you don't need to worry about:
	 */
	protected $post_type;
	protected $post_slug;
	protected $post_singular;
	protected $post_plural;
	protected $post_singular_low;
	protected $post_plural_low;
	protected $args;
	protected $_cols;

	/**
	 * Class constructor.
	 *
	 * The $post_type parameter is used as the post type name and to build the post type labels. This
	 * means you can create a post type with just one parameter and all labels and post updated messages
	 * will be generated for you. Example:
	 *
	 * register_extended_post_type( 'event' );
	 *
	 * The plural name for a post type is generated by appending an 's' to $post_type. You can override
	 * this with the $plural parameter if necessary. Example:
	 *
	 * register_extended_post_type( 'person', array(), 'people' );
	 *
	 * The post type slug is generated from the plural (which is either $post_type appended with 's' or
	 * the $plural parameter). This can be overridden with the $slug parameter if necessary. Example:
	 *
	 * register_extended_post_type( 'person', array(), 'people', 'meet-the-team' );
	 *
	 * The $args parameter accepts all the standard arguments for register_post_type() in addition to
	 * several custom arguments that provide extended functionality:
	 *
	 * - archive_in_nav_menus - boolean - Whether to show an 'All Items' checkbox for this post type on
	 * the nav menus screen so the post type archive can easily be added to a nav menu without manually
	 * adding a custom link. Uses the 'all_items' label for the nav menus screen checkbox and the 'name'
	 * label for the actual menu item. Defaults to true. Only used if show_in_nav_menus and has_archive
	 * are both also true.
	 *
	 * - quick_edit - boolean - Whether to show Quick Edit links for this post type. Defaults to true.
	 *
	 * - right_now - boolean - Whether to show this post type on the 'Right Now' section of WordPress'
	 * dashboard. Defaults to true if the post type is public, false if not.
	 *
	 * - show_in_feed - boolean - Whether to include this post type in the site's main feed. Defaults to
	 * false.
	 *
	 * - archive - array - Associative array of query vars to override on this post type's archive.
	 * Handy for setting 'no_paging' to true, for example. Defaults to null (no overridden query vars).
	 *
	 * - cols - array - Associative array of admin columns to show for this post type. See the cols()
	 * method of this class for more information. Defaults to null (no custom columns).
	 *
	 * - filters - array - Associative array of admin filters to show for this post type. See the
	 * filters() method of this class for more information. Defaults to null (no custom filters).
	 *
	 * - enter_title_here - string - Placeholder text which appears in the title field for this post type.
	 *
	 * - featured_image - string - Text which replaces 'Featured Image' for this post type.
	 *
	 * @param string $post_type The post type name
	 * @param array $args The post type arguments (optional)
	 * @param string $plural The post type plural name (optional)
	 * @param string $slug The post type slug (optional)
	 * @param string $singular The post type singular name (optional)
	 * @return null
	 */
	public function __construct( $post_type, $args = array(), $plural = null, $slug = null, $singular = null ) {

		if ( $singular )
			$this->post_singular = $singular;
		else
			$this->post_singular = $post_type;

		if ( $slug )
			$this->post_slug = $slug;
		else if ( $plural )
			$this->post_slug = $plural;
		else
			$this->post_slug = $post_type . 's';

		if ( $plural )
			$this->post_plural = $plural;
		else
			$this->post_plural = $this->post_slug;

		$this->post_type = strtolower( $post_type );
		$this->post_slug = strtolower( $this->post_slug );

		# Build our base post type names:
		$this->post_singular     = ucwords( str_replace( array( '-', '_' ), ' ', $this->post_singular ) );
		$this->post_plural       = ucwords( str_replace( array( '-', '_' ), ' ', $this->post_plural ) );
		$this->post_singular_low = strtolower( $this->post_singular );
		$this->post_plural_low   = strtolower( $this->post_plural );

		# Build our labels:
		$this->defaults['labels'] = array(
			'name'               => $this->post_plural,
			'singular_name'      => $this->post_singular,
			'menu_name'          => $this->post_plural,
			'name_admin_bar'     => $this->post_singular,
			'add_new'            => 'Add New',
			'add_new_item'       => sprintf( 'Add New %s', $this->post_singular ),
			'edit_item'          => sprintf( 'Edit %s', $this->post_singular ),
			'new_item'           => sprintf( 'New %s', $this->post_singular ),
			'view_item'          => sprintf( 'View %s', $this->post_singular ),
			'search_items'       => sprintf( 'Search %s', $this->post_plural ),
			'not_found'          => sprintf( 'No %s found', $this->post_plural_low ),
			'not_found_in_trash' => sprintf( 'No %s found in trash', $this->post_plural_low ),
			'parent_item_colon'  => sprintf( 'Parent %s', $this->post_singular ),
			'all_items'          => sprintf( 'All %s', $this->post_plural ),
		);

		# 'public' is a meta argument, so set some defaults if it's present:
		# @TODO this is not strictly true: http://core.trac.wordpress.org/ticket/20098#comment:4
		if ( isset( $args['public'] ) ) {
			$this->defaults['publicly_queryable']  =  $args['public'];
			$this->defaults['show_ui']             =  $args['public'];
			$this->defaults['show_in_menu']        =  $args['public'];
			$this->defaults['show_in_nav_menus']   =  $args['public'];
			$this->defaults['exclude_from_search'] = !$args['public'];
		}

		# 'show_ui' is a meta argument, so set some defaults if it's present:
		if ( isset( $args['show_ui'] ) )
			$this->defaults['show_in_menu'] = $args['show_ui'];

		# Only set rewrites if we need them
		if ( ( isset( $args['publicly_queryable'] ) and !$args['publicly_queryable'] ) or ( !$this->defaults['publicly_queryable'] ) ) {
			$this->defaults['rewrite'] = false;
		} else {
			$this->defaults['rewrite'] = array(
				'slug'       => $this->post_slug,
				'with_front' => false
			);
		}

		# Merge our args with the defaults:
		$this->args = wp_parse_args( $args, $this->defaults );

		# I can't remember why this is here, but it needs to be here:
		if ( !isset( $args['exclude_from_search'] ) )
			$this->args['exclude_from_search'] = !$this->args['publicly_queryable'];

		# Set Right Now visibility:
		if ( null === $this->args['right_now'] )
			$this->args['right_now'] = $this->args['public'];

		# This allows the 'labels' arg to contain some, none or all labels:
		if ( isset( $args['labels'] ) )
			$this->args['labels'] = wp_parse_args( $args['labels'], $this->defaults['labels'] );

		if ( is_admin() ) {

			# Admin columns:
			if ( $this->args['cols'] ) {
				add_filter( 'manage_posts_columns',                            array( $this, '_log_default_cols' ), 0 );
				add_filter( 'manage_pages_columns',                            array( $this, '_log_default_cols' ), 0 );
				add_filter( "manage_edit-{$this->post_type}_sortable_columns", array( $this, 'sortables' ) );
				add_filter( "manage_{$this->post_type}_posts_columns",         array( $this, 'cols' ) );
				add_action( "manage_{$this->post_type}_posts_custom_column",   array( $this, 'col' ), 10, 2 );
				add_action( 'load-edit.php',                                   array( $this, 'default_sort' ) );
				add_action( 'load-edit.php',                                   array( $this, 'maybe_sort' ) );
			}

			# Admin filters:
			if ( $this->args['filters'] ) {
				add_action( 'load-edit.php', array( $this, 'maybe_filter' ) );
				add_filter( 'query_vars',    array( $this, 'add_filter_query_vars' ) );
			}

			# 'Enter title here' filter:
			if ( $this->args['enter_title_here'] )
				add_filter( 'enter_title_here', array( $this, 'enter_title_here' ), 10, 2 );

			# Featured Image title:
			if ( $this->args['featured_image'] )
				add_filter( 'gettext', array( $this, 'featured_image_text' ) );

			# Quick Edit:
			if ( !$this->args['quick_edit'] ) {
				add_filter( 'post_row_actions',                     array( $this, 'remove_quick_edit_action' ) );
				add_filter( 'page_row_actions',                     array( $this, 'remove_quick_edit_action' ) );
				add_filter( "bulk_actions-edit-{$this->post_type}", array( $this, 'remove_quick_edit_menu' ) );
			}

			# 'Right Now' dashboard widget:
			if ( $this->args['right_now'] )
				add_action( 'right_now_content_table_end', array( $this, 'right_now' ) );

			# Nav menus screen item:
			if ( $this->args['archive_in_nav_menus'] and $this->args['show_in_nav_menus'] and $this->args['has_archive'] )
				add_filter( "nav_menu_items_{$this->post_type}", array( $this, 'nav_menu_items' ), 10, 3 );

			# Post updated messages:
			add_filter( 'post_updated_messages',      array( $this, 'post_updated_messages' ), 1 );
			add_filter( 'bulk_post_updated_messages', array( $this, 'bulk_post_updated_messages' ), 1, 2 );

		} else {

			# Post type in the site's main feed:
			if ( $this->args['show_in_feed'] )
				add_filter( 'request', array( $this, 'add_to_feed' ) );

			# Post type archive query var overrides:
			if ( $this->args['archive'] )
				add_filter( 'parse_request', array( $this, 'override_private_query_vars' ), 1 );

		}

		# Register post type when WordPress initialises:
		if ( 'init' === current_filter() )
			call_user_func( array( $this, 'register_post_type' ) );
		else
			add_action( 'init', array( $this, 'register_post_type' ), 9 );

	}

	/**
	 * Set the default sort field and sort order on our post type admin screen.
	 *
	 * @return null
	 */
	public function default_sort() {

		if ( !get_current_screen() or ( $this->post_type != get_current_screen()->post_type ) )
			return;

		# If we've already ordered the screen, bail out:
		if ( isset( $_GET['orderby'] ) )
			return;

		# Loop over our columns to find the default sort column (if there is one):
		foreach ( $this->args['cols'] as $id => $col ) {
			if ( is_array( $col ) and isset( $col['default'] ) ) {
				$_GET['orderby'] = $id;
				$_GET['order'] = ( 'desc' == strtolower( $col['default'] ) ? 'desc' : 'asc' );
				break;
			}
		}

	}

	/**
	 * Add the relevant filters for sorting posts by our sortable fields.
	 *
	 * @return null
	 */
	public function maybe_sort() {

		if ( !get_current_screen() or ( $this->post_type != get_current_screen()->post_type ) )
			return;

		add_filter( 'request',       array( $this, 'sort_posts_by_post_meta' ) );
		add_filter( 'request',       array( $this, 'sort_posts_by_post_field' ) );
		add_filter( 'posts_clauses', array( $this, 'sort_posts_by_taxonomy' ), 10, 2 );

	}

	/**
	 * Add the relevant filters for filtering posts by our custom filters.
	 *
	 * @return null
	 */
	public function maybe_filter() {

		if ( !get_current_screen() or ( $this->post_type != get_current_screen()->post_type ) )
			return;

		add_filter( 'request',               array( $this, 'filter_posts_by_post_meta' ) );
		add_action( 'restrict_manage_posts', array( $this, 'filters' ) );

	}

	/**
	 * Set the placeholder text for the title field for this post type.
	 *
	 * @param $title string The placeholder text
	 * @param $post object The current post
	 * @return string The updated placeholder text
	 */
	public function enter_title_here( $title, $post ) {

		if ( $this->post_type != $post->post_type )
			return $title;

		return $this->args['enter_title_here'];

	}

	/**
	 * @TODO Description
	 *
	 * See http://core.trac.wordpress.org/ticket/19257
	 *
	 * @param string $text
	 * @return string
	 */
	function featured_image_text( $text ) {

		if ( false === stripos( $text, 'featured image' ) )
			return $text;

		if ( $this->post_type != $this->get_current_post_type() )
			return $text;

		$text = str_replace( 'featured image', strtolower( $this->args['featured_image'] ), $text );
		$text = str_replace( 'Featured Image', $this->args['featured_image'], $text );

		return $text;

	}

	/**
	 * @TODO Description
	 *
	 * @return string
	 */
	function get_current_post_type() {

		if ( isset( $this->current_post_type ) )
			return $this->current_post_type;

		if ( function_exists( 'get_current_screen' ) and is_object( get_current_screen() ) )
			$post_type = get_current_screen()->post_type;
		else
			$post_type = '';

		if ( empty( $post_type ) ) {
			if ( isset( $_REQUEST['post_type'] ) )
				$post_type = $_REQUEST['post_type'];
			else if ( isset( $_REQUEST['post'] ) )
				$post_type = get_post_type( $_REQUEST['post'] );
			else if ( isset( $_REQUEST['post_id'] ) )
				$post_type = get_post_type( $_REQUEST['post_id'] );
			else if ( isset( $_REQUEST['attachment_id'] ) )
				$post_type = get_post_type( get_post( $_REQUEST['attachment_id'] )->post_parent );
		}

		return $this->current_post_type = $post_type;

	}

	/**
	 * Output custom filter dropdown menus on the admin screen for this post type.
	 *
	 * Each item in the 'filters' array is an associative array of information for a filter. Defining a
	 * filter is easy. Just define an array which includes the filter title and filter type. You can
	 * display filters for post meta fields and taxonomy terms.
	 *
	 * The example below adds filters for the 'event_type' meta key and the 'location' taxonomy:
	 *
	 * register_extended_post_type( 'event', array(
	 *     'filters' => array(
	 *         'event_type' => array(
	 *             'title'    => 'Event Type',
	 *             'meta_key' => 'event_type'
	 *         ),
	 *         'event_location' => array(
	 *             'title'    => 'Location',
	 *             'taxonomy' => 'location'
	 *         ),
	 *         'event_is' => array(
	 *             'title'       => 'All Events',
	 *             'meta_exists' => array(
	 *                 'event_featured'  => 'Featured Events',
	 *                 'event_cancelled' => 'Cancelled Events'
	 *             )
	 *         ),
	 *     )
	 * ) );
	 *
	 * That's all you need to do. WordPress handles taxonomy term filtering itself (the plugin just
	 * outputs the dropdown), and the plugin handles the dropdown menu and filtering for post meta.
	 *
	 * Each item in the 'filters' array needs either a 'taxonomy', 'meta_key' or 'meta_exists' element
	 * containing the corresponding taxonomy name or post meta key.
	 *
	 * The 'meta_exists' filter outputs a dropdown menu listing each of the meta_exists fields,
	 * allowing users to filter the screen by posts which have the corresponding meta field.
	 *
	 * There are a couple of optional elements:
	 *
	 * - title - The filter title. If omitted, the title will use the all_items taxonomy label or a
	 * formatted version of the post meta key.
	 *
	 * - cap - A capability required in order for this filter to be displayed to the current user. Defaults
	 * to null, meaning the filter is shown to all users.
	 *
	 * @return null
	 */
	public function filters() {

		global $wpdb;

		$pto = get_post_type_object( $this->post_type );

		foreach ( $this->args['filters'] as $filter_key => $filter ) {

			if ( isset( $filter['cap'] ) and !current_user_can( $filter['cap'] ) )
				continue;

			if ( isset( $filter['taxonomy'] ) ) {

				$tax = get_taxonomy( $filter['taxonomy'] );

				if ( empty( $tax ) )
					continue;

				# For this, we need the dropdown walker from Extended Taxonomies:
				if ( !class_exists( $class = 'Walker_ExtendedTaxonomyDropdown' ) ) {
					trigger_error( sprintf( __( 'The %s class is required in order to display taxonomy filters', 'ext_cpts' ), $class ), E_USER_WARNING );
					continue;
				} else {
					$walker = new Walker_ExtendedTaxonomyDropdown( array(
						'field' => 'slug'
					) );
				}

				# If we haven't specified a title, use the all_items label from the taxonomy:
				if ( !isset( $filter['title'] ) )
					$filter['title'] = $tax->labels->all_items;

				# Output the dropdown:
				wp_dropdown_categories( array(
					'show_option_all' => $filter['title'] . '&nbsp;',
					'hide_empty'      => false,
					'hide_if_empty'   => true,
					'hierarchical'    => true,
					'show_count'      => false,
					'orderby'         => 'name',
					'selected_cats'   => get_query_var( $tax->query_var ),
					'id'              => 'filter_' . $filter_key,
					'name'            => $tax->query_var,
					'taxonomy'        => $filter['taxonomy'],
					'walker'          => $walker
				) );

			} else if ( isset( $filter['meta_key'] ) ) {

				# If we haven't specified a title, generate one from the meta key:
				if ( !isset( $filter['title'] ) ) {
					$filter['title'] = str_replace( array( '-', '_' ), ' ', $filter['meta_key'] );
					$filter['title'] = ucwords( $filter['title'] ) . 's';
					$filter['title'] = sprintf( __( 'All %s', 'ext_cpts' ), $filter['title'] );
				}

				if ( !isset( $filter['options'] ) ) {
					# Fetch all the values for our meta key:
					$filter['options'] = $wpdb->get_col( $wpdb->prepare( "
						SELECT DISTINCT meta_value
						FROM {$wpdb->postmeta} as m
						JOIN {$wpdb->posts} as p ON ( p.ID = m.post_id )
						WHERE m.meta_key = %s
						AND m.meta_value != ''
						AND p.post_type = %s
						ORDER BY m.meta_value ASC
					", $filter['meta_key'], $this->post_type ) );
				} else if ( is_callable( $filter['options'] ) ) {
					$filter['options'] = call_user_func( $filter['options'] );
				}

				if ( empty( $filter['options'] ) )
					continue;

				$selected = stripslashes( get_query_var( $filter_key ) );

				# Output the dropdown:
				?>
				<select name="<?php echo esc_attr( $filter_key ); ?>" id="filter_<?php echo esc_attr( $filter_key ); ?>">
					<option value=""><?php echo esc_html( $filter['title'] ); ?>&nbsp;</option>
					<?php foreach ( $filter['options'] as $v ) { ?>
						<option value="<?php echo esc_attr( $v ); ?>" <?php selected( $selected, $v ); ?>><?php echo esc_html( $v ); ?></option>
					<?php } ?>
				</select>
				<?php

			} else if ( isset( $filter['meta_search_key'] ) ) {

				# If we haven't specified a title, generate one from the meta key:
				if ( !isset( $filter['title'] ) ) {
					$filter['title'] = str_replace( array( '-', '_' ), ' ', $filter['meta_search_key'] );
					$filter['title'] = ucwords( $filter['title'] );
				}

				$value = stripslashes( get_query_var( $filter_key ) );

				# Output the search box:
				?>
				<label><?php printf( '%s:', esc_html( $filter['title'] ) ); ?>&nbsp;<input type="text" name="<?php echo esc_attr( $filter_key ); ?>" id="filter_<?php echo esc_attr( $filter_key ); ?>" value="<?php echo esc_attr( $value ); ?>" /></label>
				<?php

			} else if ( isset( $filter['meta_exists'] ) ) {

				# If we haven't specified a title, use the all_items label from the post type:
				if ( !isset( $filter['title'] ) )
					$filter['title'] = $pto->labels->all_items;

				$selected = stripslashes( get_query_var( $filter_key ) );

				if ( 1 == count( $filter['meta_exists'] ) ) {

					# Output a checkbox:
					foreach ( $filter['meta_exists'] as $v => $t ) {
						?>
						<label><input type="checkbox" name="<?php echo esc_attr( $filter_key ); ?>" id="filter_<?php echo esc_attr( $filter_key ); ?>" value="<?php echo esc_attr( $v ); ?>" <?php checked( $selected, $v ); ?>>&nbsp;<?php echo esc_html( $t ); ?></label>
						<?php
					}

				} else {

					# Output a dropdown:
					?>
					<select name="<?php echo esc_attr( $filter_key ); ?>" id="filter_<?php echo esc_attr( $filter_key ); ?>">
						<option value=""><?php echo esc_html( $filter['title'] ); ?>&nbsp;</option>
						<?php foreach ( $filter['meta_exists'] as $v => $t ) { ?>
							<option value="<?php echo esc_attr( $v ); ?>" <?php selected( $selected, $v ); ?>><?php echo esc_html( $t ); ?></option>
						<?php } ?>
					</select>
					<?php

				}

			}

		}

	}

	/**
	 * Add our post meta filter names to the public query vars.
	 *
	 * @param array $vars Public query variables
	 * @return array Updated public query variables
	 */
	public function add_filter_query_vars( $vars ) {

		foreach ( $this->args['filters'] as $filter_key => $filter ) {
			if ( isset( $filter['meta_key'] ) or isset( $filter['meta_search_key'] ) or isset( $filter['meta_exists'] ) )
				$vars[] = $filter_key;
		}

		return $vars;

	}

	/**
	 * Add our post meta filters to the request parameters.
	 *
	 * @param array $vars Request parameters
	 * @return array Updated request parameters
	 */
	public function filter_posts_by_post_meta( $vars ) {

		foreach ( $this->args['filters'] as $filter_key => $filter ) {

			if ( isset( $filter['cap'] ) and !current_user_can( $filter['cap'] ) )
				continue;

			if ( isset( $filter['meta_key'] ) and isset( $vars[$filter_key] ) and !empty( $vars[$filter_key] ) ) {
				$args = array(
					'key'   => $filter['meta_key'],
					'value' => stripslashes( $vars[$filter_key] )
				);
				if ( isset( $filter['meta_compare'] ) )
					$args['compare'] = $filter['meta_compare'];
				$vars['meta_query'][] = $args;
			} else if ( isset( $filter['meta_search_key'] ) and isset( $vars[$filter_key] ) and !empty( $vars[$filter_key] ) ) {
				# @TODO kill the meta_search_key parameter and user meta_key with some complimentary parameters
				$vars['meta_query'][] = array(
					'key'     => $filter['meta_search_key'],
					'value'   => stripslashes( $vars[$filter_key] ),
					'compare' => 'LIKE'
				);
			} else if ( isset( $filter['meta_exists'] ) and isset( $vars[$filter_key] ) and !empty( $vars[$filter_key] ) ) {
				$args = array(
					'key'     => stripslashes( $vars[$filter_key] ),
				);
				if ( isset( $filter['meta_value'] ) ) {
					$args['value'] = $filter['meta_value'];
					if ( isset( $filter['meta_compare'] ) )
						$args['compare'] = $filter['meta_compare'];
				} else {
					$args['compare'] = 'NOT IN';
					$args['value']   = array( '', '0', 'false', 'null' );
				}
				$vars['meta_query'][] = $args;
			}

		}

		return $vars;

	}

	/**
	 * Add our post type to the 'Right Now' widget on WordPress' dashboard.
	 *
	 * @return null
	 */
	public function right_now() {

		# Get the labels and format the counts:
		$pto   = get_post_type_object( $this->post_type );
		$count = wp_count_posts( $this->post_type );
		$text  = $this->n( $pto->labels->singular_name, $pto->labels->name, $count->publish );
		$num   = number_format_i18n( $count->publish );

		# Add edit links if the user has permissions:
		if ( current_user_can( $pto->cap->edit_posts ) ) {
			$num  = '<a href="edit.php?post_type=' . $this->post_type . '">' . $num . '</a>';
			$text = '<a href="edit.php?post_type=' . $this->post_type . '">' . $text . '</a>';
		}

		# Output it:
		echo '<tr>';
		echo '<td class="first b b-' . $this->post_type . '">' . $num . '</td>';
		echo '<td class="t ' . $this->post_type . '">' . $text . '</td>';
		echo '</tr>';

	}

	/**
	 * Add our post type updated messages.
	 *
	 * The messages are as follows:
	 *
	 *   1 => "Post updated. {View Post}"
	 *   2 => "Custom field updated."
	 *   3 => "Custom field deleted."
	 *   4 => "Post updated."
	 *   5 => "Post restored to revision from [date]."
	 *   6 => "Post published. {View post}"
	 *   7 => "Post saved."
	 *   8 => "Post submitted. {Preview post}"
	 *   9 => "Post scheduled for: [date]. {Preview post}"
	 *  10 => "Post draft updated. {Preview post}"
	 *
	 * @param array $messages An associative array of post updated messages with post type as keys.
	 * @return array Updated array of post updated messages.
	 */
	public function post_updated_messages( $messages ) {

		global $post;

		$pto = get_post_type_object( $this->post_type );

		$messages[$this->post_type] = array(
			1 => sprintf( ( $pto->publicly_queryable ? '%1$s updated. <a href="%2$s">View %3$s</a>' : '%1$s updated.' ),
				$this->post_singular,
				esc_url( get_permalink( $post->ID ) ),
				$this->post_singular_low
			),
			2 => 'Custom field updated.',
			3 => 'Custom field deleted.',
			4 => sprintf( '%s updated.',
				$this->post_singular
			),
			5 => isset( $_GET['revision'] ) ? sprintf( '%1$s restored to revision from %2$s',
				$this->post_singular,
				wp_post_revision_title( intval( $_GET['revision'] ), false )
			) : false,
			6 => sprintf( ( $pto->publicly_queryable ? '%1$s published. <a href="%2$s">View %3$s</a>' : '%1$s published.' ),
				$this->post_singular,
				esc_url( get_permalink( $post->ID ) ),
				$this->post_singular_low
			),
			7 => sprintf( '%s saved.',
				$this->post_singular
			),
			8 => sprintf( ( $pto->publicly_queryable ? '%1$s submitted. <a target="_blank" href="%2$s">Preview %3$s</a>' : '%1$s submitted.' ),
				$this->post_singular,
				esc_url( add_query_arg( 'preview', 'true', get_permalink( $post->ID ) ) ),
				$this->post_singular_low
			),
			9 => sprintf( ( $pto->publicly_queryable ? '%1$s scheduled for: <strong>%2$s</strong>. <a target="_blank" href="%3$s">Preview %4$s</a>' : '%1$s scheduled for: <strong>%2$s</strong>.' ),
				$this->post_singular,
				date_i18n( 'M j, Y @ G:i', strtotime( $post->post_date ) ),
				esc_url( get_permalink( $post->ID ) ),
				$this->post_singular_low
			),
			10 => sprintf( ( $pto->publicly_queryable ? '%1$s draft updated. <a target="_blank" href="%2$s">Preview %3$s</a>' : '%1$s draft updated.' ),
				$this->post_singular,
				esc_url( add_query_arg( 'preview', 'true', get_permalink( $post->ID ) ) ),
				$this->post_singular_low
			),
		);

		return $messages;

	}

	/**
	 * Add our bulk post type updated messages.
	 *
	 * These messages are not yet in WordPress core.
	 * @see http://core.trac.wordpress.org/ticket/18710
	 *
	 * The messages are as follows:
	 *
	 *   1 => "Post updated." | "[n] posts updated."
	 *   2 => "Post not updated, somebody is editing it." | "[n] posts not updated, somebody is editing them."
	 *   3 => "Post permanently deleted." | "[n] posts permanently deleted."
	 *   4 => "Post moved to the trash." | "[n] posts moved to the trash."
	 *   5 => "Post restored from the trash." | "[n] posts restored from the trash."
	 *
	 * @param array $messages An associative array of bulk post updated messages with post type as keys.
	 * @return array Updated array of bulk post updated messages.
	 */
	public function bulk_post_updated_messages( $messages, $counts ) {

		$messages[$this->post_type] = array(
			1 => sprintf( $this->n( '%2$s updated.', '%1$s %3$s updated.', $counts[1] ),
				$counts[1],
				$this->post_singular,
				$this->post_plural_low
			),
			2 => sprintf( $this->n( '%2$s not updated, somebody is editing it.', '%1$s %3$s not updated, somebody is editing them.', $counts[2] ),
				$counts[2],
				$this->post_singular,
				$this->post_plural_low
			),
			3 => sprintf( $this->n( '%2$s permanently deleted.', '%1$s %3$s permanently deleted.', $counts[3] ),
				$counts[3],
				$this->post_singular,
				$this->post_plural_low
			),
			4 => sprintf( $this->n( '%2$s moved to the trash.', '%1$s %3$s moved to the trash.', $counts[4] ),
				$counts[4],
				$this->post_singular,
				$this->post_plural_low
			),
			5 => sprintf( $this->n( '%2$s restored from the trash.', '%1$s %3$s restored from the trash.', $counts[5] ),
				$counts[5],
				$this->post_singular,
				$this->post_plural_low
			),
		);

		return $messages;

	}

	/**
	 * Sort posts by post meta value.
	 *
	 * @param array $vars Request parameters
	 * @return array Updated request parameters
	 */
	public function sort_posts_by_post_meta( $vars ) {

		if ( !isset( $vars['orderby'] ) )
			return $vars;
		if ( !isset( $this->args['cols'][$vars['orderby']] ) )
			return $vars;
		if ( !is_array( $this->args['cols'][$vars['orderby']] ) )
			return $vars;
		if ( !isset( $this->args['cols'][$vars['orderby']]['meta_key'] ) )
			return $vars;

		$vars['meta_key'] = $this->args['cols'][$vars['orderby']]['meta_key'];
		$vars['orderby']  = 'meta_value';

		return $vars;

	}

	/**
	 * Sort posts by post field.
	 *
	 * @param array $vars Request parameters
	 * @return array Updated request parameters
	 */
	public function sort_posts_by_post_field( $vars ) {

		if ( !isset( $vars['orderby'] ) )
			return $vars;
		if ( !isset( $this->args['cols'][$vars['orderby']] ) )
			return $vars;
		if ( !is_array( $this->args['cols'][$vars['orderby']] ) )
			return $vars;
		if ( !isset( $this->args['cols'][$vars['orderby']]['post_field'] ) )
			return $vars;

		$field = str_replace( 'post_', '', $this->args['cols'][$vars['orderby']]['post_field'] );
		$vars['orderby'] = $field;

		return $vars;

	}

	/**
	 * Sort posts by taxonomy term(s).
	 *
	 * @param array $clauses Request SQL clauses
	 * @param object $q The WP_Query object
	 * @return array Updated request SQL clauses
	 */
	public function sort_posts_by_taxonomy( $clauses, $q ) {

		global $wpdb;

		if ( !isset( $q->query['orderby'] ) )
			return $clauses;
		if ( !isset( $this->args['cols'][$q->query['orderby']] ) )
			return $clauses;
		if ( !is_array( $this->args['cols'][$q->query['orderby']] ) )
			return $clauses;
		if ( !isset( $this->args['cols'][$q->query['orderby']]['taxonomy'] ) )
			return $clauses;

		# Taxonomy term ordering courtesy of http://scribu.net/wordpress/sortable-taxonomy-columns.html

		$clauses['join'] .= "
			LEFT OUTER JOIN {$wpdb->term_relationships} as ext_cpts_tr ON ( {$wpdb->posts}.ID = ext_cpts_tr.object_id )
			LEFT OUTER JOIN {$wpdb->term_taxonomy} as ext_cpts_tt ON ( ext_cpts_tr.term_taxonomy_id = ext_cpts_tt.term_taxonomy_id )
			LEFT OUTER JOIN {$wpdb->terms} as ext_cpts_t ON ( ext_cpts_tt.term_id = ext_cpts_t.term_id )
		";
		$clauses['where'] .= $wpdb->prepare( " AND ( taxonomy = %s OR taxonomy IS NULL )", $this->args['cols'][$q->query['orderby']]['taxonomy'] );
		$clauses['groupby'] = 'ext_cpts_tr.object_id';
		$clauses['orderby'] = "GROUP_CONCAT( ext_cpts_t.name ORDER BY name ASC ) ";
		$clauses['orderby'] .= ( 'ASC' == strtoupper( $q->get('order') ) ) ? 'ASC' : 'DESC';

		return $clauses;

	}

	/**
	 * Add our custom columns to the list of sortable columns.
	 *
	 * @param array $cols Associative array of sortable columns
	 * @return array Updated array of sortable columns
	 */
	public function sortables( $cols ) {

		foreach ( $this->args['cols'] as $id => $col ) {
			if ( is_array( $col ) ) {
				if ( isset( $col['sortable'] ) and !$col['sortable'] )
					continue;
				if ( isset( $col['meta_key'] ) or isset( $col['taxonomy'] ) or isset( $col['post_field'] ) )
					$cols[$id] = $id;
			}
		}

		return $cols;

	}

	/**
	 * Add columns to the admin screen for this post type.
	 *
	 * Each item in the 'cols' array is either a string name of an existing column, or an associative
	 * array of information for a custom column.
	 *
	 * Defining a custom column is easy. Just define an array which includes the column title, column
	 * type, and optional callback function. You can display columns for post meta, taxonomy terms,
	 * post fields, the featured image, and custom functions.
	 *
	 * The example below adds two columns; one which displays the value of the post's 'event_type' meta
	 * key and one which lists the post's terms from the 'location' taxonomy:
	 *
	 * register_extended_post_type( 'event', array(
	 *     'cols' => array(
	 *         'event_type' => array(
	 *             'title'    => 'Event Type',
	 *             'meta_key' => 'event_type'
	 *         ),
	 *         'event_location' => array(
	 *             'title'    => 'Location',
	 *             'taxonomy' => 'location'
	 *         )
	 *     )
	 * ) );
	 *
	 * That's all you need to do. The columns will handle all the sorting and safely outputting the data
	 * (escaping text, and comma-separating taxonomy terms). No more messing about with all of those
	 * annoyingly named column filters and actions.
	 *
	 * Each item in the 'cols' array should contain:
	 *
 	 * - A 'title' element containing the column title.
 	 * - One of the following elements which defines which type of column it is:
   	 *     - taxonomy - The name of a taxonomy
   	 *     - meta_key - A post meta key
   	 *     - post_field - The name of a post field (eg. post_excerpt)
	 *     - featured_image - A featured image size (eg. thumbnail)
	 *     - connection - A connection ID registered with the Posts 2 Posts plugin
	 *
	 * The value for the corresponding taxonomy terms, post meta or post field are safely escaped and output
	 * into the column, and the values are used to provide the sortable functionality for the column. For
	 * featured images, the post's featured image of that size will be displayed if there is one.
	 *
	 * There are a few optional elements:
	 *
 	 * - function - The name of a callback function for the column (eg. 'my_function') which gets called
	 * instead of the built-in function for handling that column. Note that it's not passed any parameters,
	 * so it must use the global $post object.
	 *
 	 * - default - Specifies that the admin screen should be sorted by this column by default (instead of
	 * sorting by post date). Can be boolean true (which will be treated as 'asc'), or 'asc' or 'desc' to
	 * explicitly control the default order.
	 *
	 * - width & height - These are only used for the 'featured_image' column type and allow you to set an
	 * explicit width and/or height on the <img> tag. Handy for downsizing the image.
	 *
	 * - field & value - These are only used for the 'connection' column type and allow you to specify a
	 * connection meta field and value from the fields argument of the connection type.
	 *
	 * - date_format - This is used with the 'meta_key' column type. The value of the meta field will be
	 * treated as a timestamp if this is present (Unix and MySQL timestamp formats are both supported in the
	 * meta value). Pass in boolean true to format the date according to the 'Date Format' setting or pass
	 * in a valid date formatting string (eg. 'd/m/Y H:i:s').
	 *
	 * - cap - A capability required in order for this column to be displayed to the current user. Defaults
	 * to null, meaning the column is shown to all users.
	 *
	 * - sortable - A boolean value which specifies whether the column should be sortable. Defaults to true.
	 *
	 * Remember, in addition to custom columns there are also columns built in to WordPress which you can
	 * use: 'comments', 'date', 'title' and 'author'. You can use these columns as the array value or as the
	 * array key with a string value to change the column title. You can also pass boolean false to remove
	 * the 'cb' or 'title' columns, which are otherwise kept regardless.
	 *
	 * @param array $cols Associative array of columns
	 * @return array Updated array of columns
	 */
	public function cols( $cols ) {

		$new_cols = array();
		$keep = array(
			'cb', 'title'
		);

		# Add existing columns we want to keep:
		foreach ( $cols as $id => $title ) {
			if ( in_array( $id, $keep ) and !isset( $this->args['cols'][$id] ) )
				$new_cols[$id] = $title;
		}

		# Add our custom columns:
		foreach ( array_filter( $this->args['cols'] ) as $id => $col ) {
			if ( is_string( $col ) and isset( $cols[$col] ) ) {
				$new_cols[$col] = $cols[$col];
			} else if ( is_string( $col ) and isset( $cols[$id] ) ) {
				$new_cols[$id] = $col;
			} else if ( 'author' === $col ) {
				# Automatic support for Co-Authors Plus plugin and special case for
				# displaying author column when the post type doesn't support 'author'
				if ( class_exists( 'coauthors_plus' ) )
					$k = 'coauthors';
				else
					$k = 'author';
				$new_cols[$k] = __( 'Author' );
			} else if ( is_array( $col ) ) {
				if ( isset( $col['cap'] ) and !current_user_can( $col['cap'] ) )
					continue;
				if ( isset( $col['connection'] ) and !function_exists( 'p2p_type' ) )
					continue;
				if ( !isset( $col['title'] ) ) {
					if ( isset( $col['taxonomy'] ) )
						$col['title'] = get_taxonomy( $col['taxonomy'] )->labels->name;
					else if ( isset( $col['post_field'] ) )
						$col['title'] = ucwords( trim( str_replace( array( 'post_', '_', ), ' ', $col['post_field'] ) ) );
					else if ( isset( $col['meta_key'] ) )
						$col['title'] = ucwords( trim( str_replace( array( '_', '-' ), ' ', $col['meta_key'] ) ) );
					else if ( isset( $col['connection'] ) and isset( $col['value'] ) )
						$col['title'] = ucwords( trim( str_replace( array( '_', '-' ), ' ', $col['value'] ) ) );
					else if ( isset( $col['connection'] ) )
						$col['title'] = ucwords( trim( str_replace( array( '_', '-' ), ' ', $col['connection'] ) ) );
					else
						$col['title'] = '';
				}
				$new_cols[$id] = $col['title'];
			}
		}

		# Re-add any custom columns:
		$custom   = array_diff_key( $cols, $this->_cols );
		$new_cols = array_merge( $new_cols, $custom );

		return $new_cols;

	}

	/**
	 * Output the column data for our custom columns.
	 *
	 * @param string $col The column name
	 * @param int $post_id The post ID
	 * @return null
	 */
	public function col( $col, $post_id ) {

		# Shorthand:
		$c = $this->args['cols'];

		# We're only interested in our custom columns:
		$custom_cols = array_filter( array_keys( $c ) );

		if ( !in_array( $col, $custom_cols ) )
			return;

		if ( isset( $c[$col]['post_cap'] ) and !current_user_can( $c[$col]['post_cap'], get_the_ID() ) )
			return;

		if ( isset( $c[$col]['function'] ) )
			call_user_func( $c[$col]['function'] );
		else if ( isset( $c[$col]['meta_key'] ) )
			$this->col_post_meta( $c[$col]['meta_key'], $c[$col] );
		else if ( isset( $c[$col]['taxonomy'] ) )
			$this->col_taxonomy( $c[$col]['taxonomy'], $c[$col] );
		else if ( isset( $c[$col]['post_field'] ) )
			$this->col_post_field( $c[$col]['post_field'], $c[$col] );
		else if ( isset( $c[$col]['featured_image'] ) )
			$this->col_featured_image( $c[$col]['featured_image'], $c[$col] );
		else if ( isset( $c[$col]['connection'] ) )
			$this->col_connection( $c[$col]['connection'], $c[$col] );

	}

	/**
	 * Output column data for a post meta field.
	 *
	 * @param string $meta_key The post meta key
	 * @param array $args Optional array of arguments for this field
	 * @return null
	 */
	public function col_post_meta( $meta_key, $args = null ) {

		$val = get_post_meta( get_the_ID(), $meta_key, true );

		switch ( true ) {

			case isset( $args['date_format'] ):

				if ( true === $args['date_format'] )
					$args['date_format'] = get_option( 'date_format' );

				if ( empty( $val ) )
					_e( 'None', 'ext_cpts' );
				else if ( is_numeric( $val ) )
					echo date( $args['date_format'], $val );
				else
					echo mysql2date( $args['date_format'], $val );

				break;

			default:

				echo esc_html( $val );

				break;

		}

	}

	/**
	 * Output column data for a taxonomy's term names.
	 *
	 * @param string $taxonomy The taxonomy name
	 * @param array $args Optional array of arguments for this field
	 * @return null
	 */
	public function col_taxonomy( $taxonomy, $args = null ) {

		global $post;

		$terms = wp_get_object_terms( get_the_ID(), $taxonomy );
		$tax   = get_taxonomy( $taxonomy );

		if ( is_wp_error( $terms ) or empty( $terms ) )
			return;

		$out = array();

		foreach ( $terms as $term ) {

			if ( isset( $args['link'] ) ) {

				switch ( $args['link'] ) {
					case 'view':
						if ( $tax->public )
							$out[] = sprintf( '<a href="%1$s">%2$s</a>', get_term_link( $term, $tax ), $term->name );
						else
							$out[] = $term->name;
						break;
					case 'edit' :
						if ( current_user_can( $tax->cap->edit_terms ) )
							$out[] = sprintf( '<a href="%1$s">%2$s</a>', get_edit_term_link( $term, $tax, $post->post_type ), $term->name );
						else
							$out[] = $term->name;
						break;
					case 'list':
						$link = add_query_arg( array(
							'post_type' => $post->post_type,
							$taxonomy   => $term->slug
						), admin_url( 'edit.php' ) );
						$out[] = sprintf( '<a href="%1$s">%2$s</a>', $link, $term->name );
						break;
				}


			} else {

				$out[] = $term->name;

			}

		}

		echo implode( ', ', $out );

	}

	/**
	 * Output column data for a post field.
	 *
	 * @param string $field The post field
	 * @param array $args Optional array of arguments for this field
	 * @return null
	 */
	public function col_post_field( $field, $args = null ) {

		global $post;

		switch ( $field ) {

			case 'post_date':
			case 'post_date_gmt':
				if ( '0000-00-00 00:00:00' == $post->$field )
					_e( 'Unpublished', 'ext_cpts' );
				else
					echo mysql2date( get_option( 'date_format' ), $post->$field );
				break;

			case 'post_modified':
			case 'post_modified_gmt':
				echo mysql2date( get_option( 'date_format' ), $post->$field );
				break;

			case 'post_status':
				if ( $status = get_post_status_object( get_post_status( $post ) ) )
					echo $status->label;
				break;

			case 'post_author':
				echo get_the_author();
				break;

			case 'post_title':
				echo get_the_title();
				break;

			case 'post_excerpt':
				echo get_the_excerpt();
				break;

			default:
				echo esc_html( $post->$field );
				break;

		}

	}

	/**
	 * Output column data for a post's featured image.
	 *
	 * @param string $image_size The image size
	 * @param array $args Optional array of 'width' and 'height' attributes for the image
	 * @return null
	 */
	public function col_featured_image( $image_size, $args = null ) {

		if ( !function_exists( 'has_post_thumbnail' ) )
			return;

		if ( isset( $args['width'] ) )
			$width = is_numeric( $args['width'] ) ? sprintf( '%dpx', $args['width']  ) : $args['width'];
		else
			$width = 'auto';

		if ( isset( $args['height'] ) )
			$height = is_numeric( $args['height'] ) ? sprintf( '%dpx', $args['height']  ) : $args['height'];
		else
			$height = 'auto';

		$image_atts = array(
			'style' => sprintf( 'width:%1$s;height:%2$s', $width, $height ),
			'title' => ''
		);

		if ( has_post_thumbnail() )
			the_post_thumbnail( $image_size, $image_atts );

	}

	/**
	 * Output column data for a Posts 2 Posts connection.
	 *
	 * @param string $connection The ID of the connection type
	 * @param array $args Optional array of arguments for a given connection type
	 * @return null
	 */
	public function col_connection( $connection, $args = null ) {

		global $post, $wp_query;

		if ( !function_exists( 'p2p_type' ) )
			return;

		$_post = $post;
		$meta  = $out = array();
		$field = 'connected_' . $connection;

		if ( isset( $args['field'] ) and isset( $args['value'] ) ) {
			$meta = array(
				'connected_meta' => array(
					$args['field'] => $args['value']
				)
			);
			$field .= sanitize_title( '_' . $args['field'] . '_' . $args['value'] );
		}

		if ( !isset( $_post->$field ) )
			p2p_type( $connection )->each_connected( $wp_query, $meta, $field );

		foreach ( $_post->$field as $post ) {

			setup_postdata( $post );

			$pto = get_post_type_object( $post->post_type );
			$pso = get_post_status_object( $post->post_status );

			if ( $pso->protected and !current_user_can( 'edit_post', $post->ID ) )
				continue;
			if ( 'trash' == $post->post_status )
				continue;

			if ( isset( $args['link'] ) ) {

				switch ( $args['link'] ) {
					case 'view':

						if ( $pto->public ) {
							if ( $pso->protected )
								$out[] = sprintf( '<a href="%1$s">%2$s</a>', add_query_arg( 'preview', 'true', get_permalink() ), get_the_title() );
							else
								$out[] = sprintf( '<a href="%1$s">%2$s</a>', get_permalink(), get_the_title() );
						} else {
							$out[] = get_the_title();
						}

						break;
					case 'edit':
						if ( current_user_can( 'edit_post', $post->ID ) )
							$out[] = sprintf( '<a href="%1$s">%2$s</a>', get_edit_post_link(), get_the_title() );
						else
							$out[] = get_the_title();
						break;
					case 'list':
						$link = add_query_arg( array_merge( array(
							'post_type'       => $_post->post_type,
							'connected_type'  => $connection,
							'connected_items' => $post->ID
						), $meta ), admin_url( 'edit.php' ) );
						$out[] = sprintf( '<a href="%1$s">%2$s</a>', $link, get_the_title() );
						break;
				}

			} else {

				$out[] = get_the_title();

			}

		}

		#wp_reset_postdata();
		$post = $_post;

		echo implode( ', ', $out );

	}

	/**
	 * Add our post type to the feed.
	 *
	 * @param array $vars Request parameters
	 * @return array Updated request parameters
	 */
	public function add_to_feed( $vars ) {

		# If it's not a feed, we're not interested:
		if ( !isset( $vars['feed'] ) )
			return $vars;

		if ( !isset( $vars['post_type'] ) )
			$vars['post_type'] = array( 'post', $this->post_type );
		else if ( is_array( $vars['post_type'] ) and ( count( $vars['post_type'] ) > 1 ) )
			$vars['post_type'][] = $this->post_type;

		return $vars;

	}

	/**
	 * Add to or override our post type archive's private query vars.
	 *
	 * @param object $wp The WP request object
	 * @return object Updated WP request object
	 */
	public function override_private_query_vars( $wp ) {

		# If it's not our post type, bail out:
		if ( !isset( $wp->query_vars['post_type'] ) or ( $this->post_type != $wp->query_vars['post_type'] ) )
			return $wp;
		# If it's a single post, bail out:
		if ( isset( $wp->query_vars['name'] ) )
			return $wp;

		# Set the vars:
		foreach ( $this->args['archive'] as $var => $value )
			$wp->query_vars[$var] = $value;

		return $wp;

	}

	/**
	 * Add our post type archive link to the nav menus screen.
	 *
	 * @param array $posts Array of post objects and pseudo-post objects to show on the screen
	 * @param array $meta_box The meta box arguments
	 * @param array $post_type The current post type in the context of the nav menus screen
	 * @return array Updated array of posts and pseudo-posts
	 */
	public function nav_menu_items( $posts, $meta_box, $post_type ) {

		global $_nav_menu_placeholder;

		$pto = $post_type['args'];
		$_nav_menu_placeholder = ( 0 > $_nav_menu_placeholder ) ? intval( $_nav_menu_placeholder ) - 1 : -1;

		# Add our 'All Posts' item to the beginning of the list:
		array_unshift( $posts, (object) array(
			'ID'           => 0,
			'object_id'    => $_nav_menu_placeholder,
			'post_content' => '',
			'post_excerpt' => '',
			'post_parent'  => 0,
			'post_type'    => 'nav_menu_item',
			'post_title'   => $pto->labels->name,
			'label'        => $pto->labels->all_items,
			'type'         => 'custom',
			'url'          => get_post_type_archive_link( $this->post_type ),
		) );

		return $posts;

	}

	/**
	 * Removes the Quick Edit link from the post row actions.
	 *
	 * @param $actions array Array of post actions
	 * @return array Array of updated post actions
	 */
	public function remove_quick_edit_action( $actions ) {

		if ( !get_current_screen() or ( $this->post_type != get_current_screen()->post_type ) )
			return $actions;

		unset( $actions['inline'], $actions['inline hide-if-no-js'] );
		return $actions;

	}

	/**
	 * Removes the Quick Edit link from the bulk actions menu.
	 *
	 * @param $actions array Array of bulk actions
	 * @return array Array of updated bulk actions
	 */
	public function remove_quick_edit_menu( $actions ) {

		if ( !get_current_screen() or ( $this->post_type != get_current_screen()->post_type ) )
			return $actions;

		unset( $actions['edit'] );
		return $actions;

	}

	/**
	 * Logs the default columns so we don't remove any custom columns added by other plugins.
	 *
	 * @param array $cols The default columns for this post type screen
	 * @return array The default columns for this post type screen
	 */
	public function _log_default_cols( $cols ) {

		return $this->_cols = $cols;

	}

	/**
	 * A non-localised version of _n()
	 *
	 * @param string $single The text that will be used if $number is 1
	 * @param string $plural The text that will be used if $number is not 1
	 * @param int $number The number to compare against to use either $single or $plural
	 * @return string Either $single or $plural text
	 */
	public function n( $single, $plural, $number ) {

		return ( 1 == $number ) ? $single : $plural;

	}

	/**
	 * Registers our post type.
	 *
	 * The only difference between this and regular register_post_type() calls is this will trigger
	 * an error of E_USER_ERROR level if a WP_Error is returned. Currently the only time you'll get
	 * an error from register_post_type() is if the post type name is too long.
	 *
	 * @return null
	 */
	public function register_post_type() {

		if ( true === $this->args['query_var'] )
			$query_var = $this->post_type;
		else
			$query_var = $this->args['query_var'];

		$existing = get_post_type_object( $this->post_type );

		if ( $query_var and count( get_taxonomies( array( 'query_var' => $query_var ) ) ) ) {

			trigger_error( sprintf( __( 'Post type query var "%s" clashes with a taxonomy query var of the same name', 'ext_cpts' ), $query_var ), E_USER_ERROR );

		} else if ( empty( $existing ) ) {

			if ( is_wp_error( $cpt = register_post_type( $this->post_type, $this->args ) ) )
				trigger_error( $cpt->get_error_message(), E_USER_ERROR );

		} else {

			# This allows us to call register_extended_post_type() on an existing post type to add custom functionality to it

			$this->extend( $existing );

		}

	}

	/**
	 * @TODO Description
	 *
	 * @param type $param
	 * @return
	 */
	public function extend( $pto ) {

		global $wp_post_types;

		$wp_post_types[$pto->name]->labels = (object) $this->args['labels'];

	}

	/**
	 * Helper function for registering a taxonomy and adding it to this post type. Accepts the same
	 * parameters as register_extended_taxonomy(), minus the $object_types parameter. Will fall back
	 * to register_taxonomy() if Extended Taxonomies isn't present.
	 *
	 * Example usage:
	 *
	 * $events   = register_extended_post_type( 'event' );
	 * $location = $events->add_taxonomy( 'location' );
	 *
	 * @return Taxonomy object
	 */
	public function add_taxonomy( $taxonomy, $args = array(), $plural = null, $slug = null, $singular = null ) {

		if ( taxonomy_exists( $taxonomy ) )
			register_taxonomy_for_object_type( $taxonomy, $this->post_type );
		else if ( function_exists( 'register_extended_taxonomy' ) )
			register_extended_taxonomy( $taxonomy, $this->post_type, $args, $plural, $slug, $singular );
		else
			register_taxonomy( $taxonomy, $this->post_type, $args );

		return get_taxonomy( $taxonomy );

	}

}

?>